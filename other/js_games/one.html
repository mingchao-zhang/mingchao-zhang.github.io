<!DOCTYPE html>
<html lang="en">
<head>

</head>

<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
//------------------------------------------------------------
var canvas, canvasContext;
var ballX = 75;
var ballY = 100;
var ballSpeedX = 5;
var ballSpeedY = 4;

const PADDLE_WIDTH = 400;
const PADDLE_THICKNESS = 50;
const PADDLE_DIST_FROM_EDGE = 50;
var paddleX = 400;

var mouseX;
var mouseY;

const BRICK_W = 80;
const BRICK_H = 20;
const BRICK_GAP = 2;
const BRICK_COLS = 10;
const BRICK_ROWS = 14;
var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);
var bricksLeft = 0;


//------------------------------------------------------------
function updateMousePos(evt) {
  var rect = canvas.getBoundingClientRect();
  var root = document.documentElement;

  mouseX = evt.clientX - rect.left - root.scrollLeft;
  mouseY = evt.clientY - rect.top - root.scrollTop;

  paddleX = mouseX - PADDLE_WIDTH / 2;

  //tesing
  /*
  ballX = mouseX;
  ballY = mouseY;
  ballSpeedX = 3;
  ballSpeedY = -4;
  */
}

//------------------------------------------------------------
window.onload = function() {
  canvas = document.getElementById('gameCanvas');
  canvasContext = canvas.getContext('2d');

  var framesPerSecond = 60;
  brickReset();
  setInterval(updateAll, 1000 / framesPerSecond);

  canvas.addEventListener('mousemove', updateMousePos);

}

//------------------------------------------------------------
function ballReset() {
  ballX = canvas.width / 2;
  ballY = canvas.height / 2;
  ballSpeedX = 5;
  ballSpeedY = 4;
}

//------------------------------------------------------------
function updateAll() {
  moveAll();
  drawAll();
}

//------------------------------------------------------------
function ballMove() {
  ballX += ballSpeedX;
  ballY += ballSpeedY;

  if (ballX > canvas.width && ballSpeedX > 0.0) {
    ballSpeedX *= -1;
  }
  else if (ballX < 0 && ballSpeedX < 0.0) {
    ballSpeedX *= -1;
  }

  if (ballY > canvas.height) {
    ballSpeedY *= -1;
    ballReset();
    brickReset();
  }
  else if (ballY < 0) {
    ballSpeedY *= -1;
  }
}
//------------------------------------------------------------
function isBrickAtRowCol(row, col) {
  if (col >= 0 && col < BRICK_COLS &&
      row >= 0 && row < BRICK_ROWS) {
    var brickIndexUnderCoord = rowColToArrayIndex(row, col);
    return brickGrid[brickIndexUnderCoord];
  }
  else {
    return false;
  }
}
function ballBrickHandling() {
  var ballBrickCol = Math.floor(ballX / BRICK_W);
  var ballBrickRow = Math.floor(ballY / BRICK_H);
  var brickIndexunderBall = rowColToArrayIndex(ballBrickRow, ballBrickCol);

  if (ballBrickCol >= 0 && ballBrickCol < BRICK_COLS &&
      ballBrickRow >= 0 && ballBrickRow < BRICK_ROWS) {
      if (isBrickAtRowCol(ballBrickRow, ballBrickCol)) {
        brickGrid[brickIndexunderBall] = false;
        bricksLeft--;
        var hitted = (BRICK_COLS * BRICK_ROWS) - bricksLeft;
        ballSpeedX *= (1 + hitted * 0.0001);
        ballSpeedY *= (1 + hitted * 0.00008);
        console.log(bricksLeft);
        var prevBallX = ballX - ballSpeedX;
        var prevBallY = ballY - ballSpeedY;
        var prevBrickCol = Math.floor(prevBallX / BRICK_W);
        var prevBrickRow = Math.floor(prevBallY / BRICK_H);

        var bothTestsFailed = true;
        if (prevBrickRow != ballBrickRow) {
          var adjBrickSide = rowColToArrayIndex(ballBrickRow, prevBrickCol);
          if ( isBrickAtRowCol(ballBrickRow, prevBrickCol) == false) {
            ballSpeedY *= -1;
            bothTestsFailed = false;
          }
        }
        if (prevBrickCol != ballBrickCol) {
          var adjBrickTopBot = rowColToArrayIndex(prevBrickRow, ballBrickCol);
          if ( isBrickAtRowCol(prevBrickRow, ballBrickCol) == false) {
            ballSpeedX *= -1;
            bothTestsFailed = false;
          }
        }
        if (bothTestsFailed) {
          ballSpeedX *= -1;
          ballSpeedY *= -1;
        }
      }
  }
}

//------------------------------------------------------------
function ballPaddleHandling() {
  var paddleTopEdgeY = canvas.height - PADDLE_DIST_FROM_EDGE;
  var paddleBottomEdgeY = paddleTopEdgeY + PADDLE_THICKNESS;
  var paddleLeftEdgeX = paddleX;
  var paddleRightEdgeX = paddleLeftEdgeX + PADDLE_WIDTH;
  if (ballY > paddleTopEdgeY &&
      ballY < paddleBottomEdgeY &&
      ballX > paddleLeftEdgeX &&
      ballX < paddleRightEdgeX) {
      ballSpeedY *= -1;

      var CenterofPaddleX = paddleX + PADDLE_WIDTH / 2;
      var delta = ballX - CenterofPaddleX;
      ballSpeedX = delta * 0.1;

      if (bricksLeft == 0) {
        brickReset();
      }
  }
}

//------------------------------------------------------------
function moveAll() {
  ballMove();
  ballBrickHandling();
  ballPaddleHandling();
}

//------------------------------------------------------------
function drawAll() {
  colorRect(0, 0, canvas.width, canvas.height, 'black');
  drawBricks();
  colorCircle(ballX, ballY, 10, 'white');

  colorRect(paddleX, canvas.height - PADDLE_DIST_FROM_EDGE, PADDLE_WIDTH, PADDLE_THICKNESS, 'white');




  //colorText(mouseBrickRow + "," + mouseBrickCol + ": " + brickIndexunderMouse, mouseX, mouseY, "yellow");
}
//------------------------------------------------------------
function brickReset() {
  bricksLeft = 0;
  var i;
  for (var i = 0; i < 3 * BRICK_COLS; i++) {
    brickGrid[i] = false;
  }
  for (; i < BRICK_ROWS * BRICK_COLS; i++) {
    brickGrid[i] = true;
    bricksLeft++;
  }
  ballReset();
  //brickGrid[15] = false;
}
//------------------------------------------------------------
function rowColToArrayIndex(row, col) {
  return BRICK_COLS * row + col;
}
//------------------------------------------------------------

function drawBricks() {
  for (var eachRow = 0; eachRow < BRICK_ROWS; eachRow++) {
    for (var eachCol = 0; eachCol < BRICK_COLS; eachCol++) {
      //console.log(eachCol, brickGrid[eachCol]);
      var arrayIndex = rowColToArrayIndex(eachRow, eachCol);
      if (brickGrid[arrayIndex]) {
        colorRect(BRICK_W * eachCol, BRICK_H * eachRow, BRICK_W - BRICK_GAP,
                  BRICK_H - BRICK_GAP, "blue");
      }
    }
  }
}
//------------------------------------------------------------
function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
  canvasContext.fillStyle = fillColor;
  canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
}

//------------------------------------------------------------
function colorCircle(centerX, centerY, radius, fillColor) {
  canvasContext.fillStyle = fillColor;
  canvasContext.beginPath();
  canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
  canvasContext.fill();
}
//------------------------------------------------------------
function colorText(showWords, textX, textY, fillColor) {
  canvasContext.fillStyle = fillColor;
  canvasContext.fillText(showWords, textX, textY);
}
</script>

</html>
